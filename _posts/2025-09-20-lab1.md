---
layout: post
title: John in a durag
subtitle: He's so tuff
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/durag.png
share-img: /assets/img/durag.jpg
tags: [tuff_heads]
author: Big John
---

Using a dataset containing data about all of the digimon, I was tasked with completing the following tasks 

1) Finding the average speed of all of the Digimon

2) Writing a function that could count the number of Digimon with a specific attribute. For example, count_digimon("Type", "Vaccine") would return 70.

3) Finding a team of up to 3 digimon such that their combined Atk values were greater than 300 and combined Memory values less than 15.

4) (For extra credit) writing a function similar to count_digimon, but, this one would count the number of digimon with a numeric value between a min and max value.

In this article, I describe my answers and process in finding them.

For the first question, when parsing through the data, I would count the total speed of all of the Digimon while also counting the number of Digimon. Then, I would divide the total speed by the number of digimon to get the average speed. The average speed was roughly 120.4.

For the second question, the function was rather uninteresting:
```python
def count_digimon(attr,val): # Returns the number of digimon that have a certain value for a particular attribute using attr_count
    try:
        return attr_count[attr][val]
    except:
        return 0
```

All that this function does is take a value from a nested dictionary. The most important part of the function is just the attr_count dictionary.
```python

attr_count = {} #Stores the amount of each value of each attribute

with open("digimon.csv","r") as f:
    data = csv.DictReader(f)
    for row in data:
        for key in row.keys():
            if key not in attr_count.keys():
                attr_count[key] = {}
            if row[key] not in attr_count[key].keys():
                attr_count[key][row[key]] = 0
            attr_count[key][row[key]] += 1
 

```

This code cycles through all of the rows in the data table, cycling through each value in the row. Since we use a DictReader for parsing the data, each row is stored as a Dictionary. For each attribute, if the value of the current Digimon hasn't been had by any of the previous Digimon, then that value is added to the attribute's dictionary. If it had already been added, then its value in that dictionary will be incremented by 1. The dictionary contains information regarding how many of each value of each attribute that there were. This means that all the function has to do is access the dictionary.

For the third question, there are plenty of teams that have less than 15 combined Memory but also over 300 Atk. Lopmon, Wormmon, and Waspmon is one such team. My code for this bit was relatively simple:
```python
for i in range(len(digimon_data)): # Prints out all combinations of three digimon with combined Atk > 300 and combined Memory < 15
    for j in range(i+1, len(digimon_data)):
        for k in range(j+1, len(digimon_data)):
            
            row1 = digimon_data[i]
            row2 = digimon_data[j]
            row3 = digimon_data[k]

            memory_sum = int(row1["Memory"])+int(row2["Memory"])+int(row3["Memory"])
            atk_sum = int(row1["Atk"])+int(row2["Atk"])+int(row3["Atk"])
            
            if memory_sum <= 15 and atk_sum >= 300:
                print(row1["Digimon"])
                print(row2["Digimon"])
                print(row3["Digimon"]+"\n")
```
All that this code does is it goes through all sets of 3 digimon and checks if that team fulfils the criteria. If so, it prints them out.

Finally, for the extra credit problem:
```python
def count_digimon_min_max(attribute, min_val, max_val): # Returns the number of digimon that have a value between a min and a max
                                                        # for some attribute that can be expressed as an integer. This function is for extra credit
    count = 0

    for i in range(min_val, max_val):
        try:
            count+=attr_count[attribute][str(i)]
        except:
            pass
    return count
```

This code cycles through the values in between min_val and max_val in the attr_count dictionary.
